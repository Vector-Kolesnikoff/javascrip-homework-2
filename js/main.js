console.log('Sample JavaScript #2 HW #16');

/*
 * #1
 *
 * Создайте объект userObj, описывающий человека.
 *
 * Следующие поля обязательны:
 * firstName – любое имя, строка
 * lastName – любая фамилия, строка
 * age – любой возраст, число
 */

var userObj = {
  firstName: 'Jonny',
  lastName: 'Profi',
  age: 1
};

/*
 * #2
 *
 * Для объекта из п.1 создайте метод fullName, который будет возвращать полное имя,
 * состоящее из firstName и lastName, склеенных в строку через пробел.
 *
 * Например:
 * userObj.firstName ← 'Имя
 * userObj.lastName ← Фамилия'
 * userObj.fullName() → 'Имя Фамилия'.
 */

userObj.fullName = function () {
  return this.firstName+' '+this.lastName
};

console.log(userObj.fullName());

/*
 * #3
 *
 * Дана функция defUpperStr('My text'), которая возвращает текст, преобразованный в верхний регистр, т.е:
 * defUpperStr('My text') → 'MY TEXT'.
 *
 * Если функция вызывается без параметра defUpperStr(), она не должна возвращать undefined,
 * в этом случае требуется вернуть строку текста по умолчанию в верхнем регистре, т.е:
 * defUpperStr() → 'DEFAULT TEXT'.
 *
 * При выполнении задачи не используйте оператор if, требуется решение с логическим оператором ||.
 */

function defUpperStr(text) {
  return(text || 'Default text').toUpperCase();
};

console.log(defUpperStr('My text'));
console.log(defUpperStr());


/*
 * #4
 *
 * Создайте функцию evenFn(n), которая принимает параметром число – количество итераций цикла,
 * т.е. for 0..n. Функция должна вернуть массив, состоящий только из четных значений, генерируемых в цикле.
 *
 * Причем:
 * 0 не должен попадать в результирующий массив
 * цикл должен работать до n включительно
 * разрешен только оператор for
 *
 * Например:
 * evenFn(10) → [2, 4, 6, 8, 10]
 * evenFn(15) → [2, 4, 6, 8, 10, 12, 14]
 * evenFn(20) → [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
 */

function evenFn(n) { // Создаём функцию с аргументом n (количество интераций будущего цикла).
  var evenArr = []; // Добавляем локальную переменную-массив, который будет возвращать функция в результате.
  
  for(var i = 1; i <= n; ++i) { // Создаём цикл в функции: инициализация i со значением 1 (с него будет начало массива), это значение будет меньше или равно количества интераций цикла, оно будет увеличиваться на 1 (++1) перед каждой интеррацией (можно сделать и после интераций (1++)).
    if (i % 2 === 0) { // При условии (условный оператор if) что остаток от деления значений i на 2 строго равно 0 (если нужны нечётные числа, ставим !== вместо ===),
      evenArr.push(i); // метод push добавляет к массиву значение i (образует счётчик).
    } // Конец условия.
  }; // Закрывается цикл.
  return evenArr; // Возврат массива.
}; // Функция закрыта.

console.log('n = 10', evenFn(10));
console.log('n = 15', evenFn(15));
console.log('n = 20', evenFn(20));

/*
 * #5
 *
 * Создайте функцию weekFn(n), которая принимает номер дня недели, а возвращает его название.
 * Если вводится строка или число вне диапазона 1..7 – функция должна вернуть null.
 *
 * Например:
 * 1 → 'Понедельник'
 * 2 → 'Вторник'
 * ...
 * 7 → 'Воскресенье'
 *
 * В реализации функции обязательно должны быть использованы операторы switch / case / default.
 */

function weekFn(n) { // Создаём функцию с n-аргументом.
  var ageNum; // Объявляем локальную переменную для дальнейшего её возврата. Значение не указываем ( или ='';).
  switch(n) { // Создаём в теле функции кнструкцию switch с тем же n-аргументом.
    case 1: ageNum = 'Понедельник'; break; // Задаём усовия: при n = 1, значение л.переменной будет 'Понедельник',
    case 2: ageNum = 'Вторник'; break; // при n = 2, значение л.переменной будет 'Вторник',
    case 3: ageNum = 'Среда'; break; // и т.д.
    case 4: ageNum = 'Четверг'; break;
    case 5: ageNum = 'Пятница'; break;
    case 6: ageNum = 'Суббота'; break;
    case 7: ageNum = 'Воскресенье'; break;
    default: ageNum = null; // В ином случае (если вместо n ввести любое другое значение кроме 1-7) будет null.
  } // Закрываем конструкцию.
  return ageNum; // Говорим функции что она должна возвращать л.переменную со значением, удовлетворяющим условие.
} 

console.log(weekFn(1));
console.log(weekFn(2));
console.log(weekFn(3));
console.log(weekFn(4));
console.log(weekFn(5));
console.log(weekFn(6));
console.log(weekFn(7));

/*
 * #6
 *
 * создайте функцию ageClassification(n), которая будет в качестве параметра принимать любые числа
 * и возвращать строку согласно следующим условиям, n:
 *           менее 0 – null
 *             0..24 – 'детский возраст'
 *           24+..44 – 'молодой возраст'
 *           44+..65 – 'средний возраст'
 *           65+..75 – 'пожилой возраст'
 *           75+..90 – 'старческий возраст'
 *          90+..122 – 'долгожители'
 *         более 122 – null
 *
 * При выполнении задания допускается использовать только тернарный оператор ?.
 * Использование операторов if, switch – запрещено.
 */

function ageClassification(n) { // Создаём функцию с n-аргументом.
  
  return n >= 0 && n <= 24 ? 'детский возраст' : // Задаём условие -  вернуть результат значения n если: n больше или равно 0 ИЛИ меньше или равно 24, то результат - строка 'детский возраст', иначе:
         n > 24 && n <= 44 ? 'молодой возраст' : // n больше или равно 25 ИЛИ меньше или равно 44, то результат - строка 'молодой возраст', иначе:
         n > 44 && n <= 65 ? 'средний возраст' : // и т.д.
         n > 65 && n <= 75 ? 'пожилой возраст' :
         n > 75 && n <= 90 ? 'старческий возраст' :
         n > 90 && n <= 122 ? 'долгожители' : null; // если нет нормального значения, удовлетворяющего функцию, тогда результат будет null.
} // Следует отметить, что всё от return до null - одно большое условие (с переносами строки).

console.log('-1: ', ageClassification(-1));
console.log('2: ',ageClassification(2));
console.log('2.4: ',ageClassification(2.4));
console.log('24.01: ',ageClassification(24.01));
console.log('25: ',ageClassification(25));
console.log('50: ',ageClassification(50));
console.log('69: ',ageClassification(69));
console.log('113: ',ageClassification(113));
console.log('150: ',ageClassification(150));

/*
 * #7
 *
 * Создайте функцию oddFn(n), которая принимает параметром число – количество итераций цикла.
 * Функция должна вернуть массив, состоящий только из нечетных значений, генерируемых в цикле.
 *
 * Причем:
 * 0 не должен попадать в результирующий массив
 * цикл должен работать до n включительно
 * разрешен только оператор while
 *
 * Например:
 * oddFn(10) → [1, 3, 5, 7, 9]
 * oddFn(15) → [1, 3, 5, 7, 9, 11, 13, 15]
 * oddFn(20) → [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
 */

function oddFn(n) { // Создаём функцию с аргументом n (количество интераций будущего цикла).
  var oddArr = [], // Добавляем локальную переменную-массив, который будет возвращать функция в результате.
      i = 0; // Так же заранее добавляем переменную i, которая будет фигурировать в цикле while (в нём не добавляют переменные).
  while(++i <= n) { // Создаём цикл в функции: инкремент можно записать где угодно в цикле, но оптимальнее здесь, его значение будет меньше или равно количеству интераций цикла, при этом оно будет увеличиваться на 1 (++1) перед каждой интеррацией (можно сделать и после интераций (1++)).
    if (i % 2 !== 0) { // При условии (условный оператор if) что остаток от деления значений i на 2 не равно 0 (если нужны чётные числа, ставим === вместо !==),
      oddArr.push(i); // метод push добавляет к массиву значение i (образует счётчик).
    } // Конец условия.
  }; // Закрывается цикл.
  return oddArr; // Возврат массива.
}; // Функция закрыта.

console.log('n = 10', oddFn(10));
console.log('n = 15', oddFn(15));
console.log('n = 20', oddFn(20));


/*
 * #8
 *
 * Создайте основную функцию mainFunc(a, b, func), которая принимает три параметра:
 * a – число
 * b - число
 * func –  обрабатывающая параметры a и b, возвратная (callback) функция
 *
 * Реализуйте проверку: если третьим параметром передается не функция, нужно вернуть false.
 *
 */

function mainFunc(a, b, func) { // Создал основную функцию, которая принимает три параметра.
  if (func && typeof func === 'function') { // При условии что третий параметр (сам параметр или его тип) является функцией,
    return func(a, b); // вернётся возвратная функция этого параметра с двумя своими параметрами (а они у нас одинаковые в основной и возвратной функциях, a и b).
  } 
  else { // Иначе...
    return false; // вернётся false.
  };
}

/*
 * реализуйте следующие функции, которые будут осуществлять механизм callback в основной функции,
 * возвращая ей результат собственного вычисления...
 * для возведения в степень и получения произвольного значения можете воспользоваться методами объекта Math.
 */

 // cbRandom(a, b) – вычисляет и возвращает произвольное целое число в диапазоне между a и b включительно.
function cbRandom(a, b) { 
  var mathCeilRandom = Math.ceil(Math.random() * (a - b) + b); // Здесь указал метод через переменную...
  return(mathCeilRandom); // и вернул её.
}

// cbPow(a, b) – вычисляет и возвращает результат возведения числа a в степень b.
function cbPow(a, b) {
  return (Math.pow(a, b)); // Здесь сразу вернул метод
}

// cbAdd(a, b) – вычисляет и возвращает сумму двух чисел a и b.
function cbAdd(a, b) { 
  return (a + b); // Тоже сразу вернул метод без всяких переменных.
}

/*
 * mainFunc() должна возвращать результат работы переданной ей возвратной функции, например:
 * mainFunc(2, 5, cbRandom) → случайно от 2 до 5 включительно
 * mainFunc(10, 30, cbRandom) → случайно 10..30 включительно
 * mainFunc(2, 5, cbPow) → 32
 * mainFunc(2, 5, cbAdd) → 7
 * mainFunc(2, 5, 'not a func') → false
 */

console.log();
console.log(mainFunc(2, 5, cbRandom)); // Вызываем функцию, одним из параметров (аргументов) которой является другая, т.н. возвратная функция
console.log(mainFunc(10, 30, cbRandom));
console.log(mainFunc(2, 5, cbPow));
console.log(mainFunc(2, 5, cbAdd));
console.log(mainFunc(2, 5, 'not a func'));